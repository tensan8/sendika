"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

// Put elements on their own line if on the same line together

/**
 * Class to create new indented stringed svg elements
 * 
 */
var j = 0;

var Format = /*#__PURE__*/function () {
  function Format() {
    var spaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
    (0, _classCallCheck2["default"])(this, Format);
    this.string = '';
    this.spaces = spaces;
  }

  (0, _createClass2["default"])(Format, [{
    key: "removeSpaces",
    value: function removeSpaces() {
      return this.string.replace(/[ ]{3,}/igm, ' ');
    }
  }, {
    key: "trimLines",
    value: function trimLines(string) {
      // Splits each line that is 180 characters or long at the very next space 
      var regex = new RegExp('(.{180}[ ])(.*)', 'igm');
      var newArr = []; // j < 50 incase extremely long and multiple lines 

      if (string.match(regex) && j < 10) {
        var strings = string.split('\n');
        var i = strings.length;

        while (i--) {
          // Each line that is too long splits and second line gets it's own
          newArr.unshift(strings[i].replace(regex, '$1\n$2'));
        }

        var newString = newArr.join('\n');
        j++;
        return this.trimLines(newString);
      } else {
        return string.replace(/^\s*\n/gm, '');
      }
    }
  }, {
    key: "newLine",
    value: function newLine(string) {
      if (typeof string !== 'string') return {
        error: '<h1>Not a valid string</h1>'
      };
      var newLinePattern = /^(.*\/?>)(<.*>?)$/igm;
      var isFormated = newLinePattern.test(string);

      if (isFormated) {
        var newString = string.replace(newLinePattern, '$1\n$2');
        return this.newLine(newString); // Updates this.newString until new line formating is done
      } else {
        return string;
      }
    }
  }, {
    key: "elementOnOwnLines",
    value: function elementOnOwnLines() {
      var string = this.removeSpaces();
      var newLine = this.newLine(string);
      var trimmed = this.trimLines(newLine);
      if (!trimmed) return {
        error: '<h1>Can\'t format new lines</h1>'
      };
      var openClosingPattern = /<\w.+[\s\S]+(<.+>)/gi;
      var openClosingElements = trimmed.match(openClosingPattern); // If empty lines exist remove them

      var emptyLinesPattern = /^\s*[\r\n]/gm;
      return openClosingElements[0].replace(emptyLinesPattern, '');
    }
  }, {
    key: "leftFormat",
    value: function leftFormat() {
      var elementOnOwnLines = this.elementOnOwnLines();

      if (!elementOnOwnLines) {
        console.log('Can\'t format Elements on Own Lines');
        return {
          error: '<h1>Can\'t format Elements on Own Lines</h1>'
        };
      } // Remove spaces from both sides


      var removeTabsPattern = /^\s*|\s*$/gm;
      var formatLeft = elementOnOwnLines.replace(removeTabsPattern, '');
      return formatLeft;
    }
  }, {
    key: "indent",
    value: function indent(string, styleElement) {
      this.string = string;
      var leftFormat = this.leftFormat();
      var selectAllLines = /.+/gi;
      var allArray = leftFormat.match(selectAllLines);
      var length = allArray.length;
      var newString = '';
      var space = 0;
      var spaces = this.spaces;

      for (var i = 0; i < length; i++) {
        var element = allArray[i];
        var beginnings = /<svg.+>|<style type="text\/css">|<[^\/].*>|^<[^\/].*[^>]$/i.test(element); // <...> or <.....

        var onelines = /<.*>.*<\/.*>|^<\w.*\/>$|^(\w|-|\.).+[^>]$|^[\w",-].+\/?>$|^['"]?\..*|<\/image>/gi.test(element); //  <./>...<./> or <..../>  or .... or .../>  or ...> or '.photo-st0{fill:#061E2D;}'+

        var endings = /(?<!.+)<\/.*>|^}?<\/style>$/gi.test(element); // Indents open elements <g> or <g className="someclass" not closing..

        if (beginnings) {
          if (/<[^\/].+[^\/]>|^\w.+[^\/]>$|<[a-z]+>/gi.test(allArray[i - 1])) {
            // Tests previous element is the same, if so add space
            space += spaces;
            newString += element.replace(/^/g, '\n' + ' '.repeat(space));
          } else {
            newString += element.replace(/^/g, i === 0 ? '' : '\n' + ' '.repeat(space)); // First line, only adds new line (\n) if it's not the first line
          }
        } // **** TO DO indent strings under the <path element  ......   ^<.+([\w\d-,.]+)$  ***
        // Indents single open and closing elements <.../> or <..>...</..>
        else if (onelines) {
          if (/^<[^\/]+>$|^<style.+{?>?$|^[\w|-|\.].+[^\/]>$/gi.test(allArray[i - 1])) {
            // tests if previouos element is <...> or <style...{ or ...> 
            space += spaces;
            newString += element.replace(/^/g, '\n' + ' '.repeat(space)); // Indents if previous line is different
          } else {
            newString += element.replace(/^/g, '\n' + ' '.repeat(space));
          }
        } // Doesn't indent closing elements </g>, </div>, }</style> etc etc..
        else if (endings) {
          var justLetters = element.replace(/[^a-zA-Z]/ig, '');
          var regex = new RegExp("^<".concat(justLetters), 'gi');

          if (regex.test(allArray[i - 1])) {
            newString += element.replace(/^/g, '\n' + ' '.repeat(space));
          } else {
            space -= spaces;
            newString += element.replace(/^/g, '\n' + ' '.repeat(space));
          }
        }
      }

      return newString;
    }
  }]);
  return Format;
}();

;
module.exports = new Format();